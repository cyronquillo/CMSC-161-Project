<!DOCTYPE html>
<html>
	<head>
		<title> GamePanel </title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.3.1/dist/semantic.min.css">
		<link rel="stylesheet" type="text/css" href="GamePanel.css">
	</head>
	<body>
		<div class="East">
			<p id = "timer" class="EastComponents">0.000</p>
			<canvas class="gameCanvas EastComponents" width="400" height="400"> </canvas>
		</div>
		<div class="Center" id="rotateCanvas">
		</div>
		<div class="South">
			<button> Check </button>
			<button> Pass </button>
			<button> Show Overlay </button>
		</div>
	</body>
	<script>
		/*Calls Timer Function on load*/
		window.onload = function(){
			timer(0);
		};
		var rotateContainer = document.getElementById("rotateCanvas");
		var rotateCanvasWidth = 900;
		var rotateCanvasHeight = 500;
		var three = THREE;
		var scene = new three.Scene();
		var camera = new three.PerspectiveCamera(75, rotateCanvasWidth / rotateCanvasHeight, 0.1, 1000);
		
		var renderer = new three.WebGLRenderer();
		renderer.setSize(900, 500);
		document.body.appendChild(renderer.domElement);
		
		var geometry = new three.BoxGeometry(1, 1, 1);
		
		three.ImageUtils.crossOrigin = '';
        var texture = three.ImageUtils.loadTexture('http://i.imgur.com/CEGihbB.gif');
		texture.anisotropy = renderer.getMaxAnisotropy();
		
		var material = new three.MeshFaceMaterial([
                    new three.MeshBasicMaterial({
                        color: 0x00ff00,
                    }),
                    new three.MeshBasicMaterial({
                        color: 0xff0000,
                    }),
                    new three.MeshBasicMaterial({
                        color: 0x0000ff,
                        // map: texture
                    }),
                    new three.MeshBasicMaterial({
                        color: 0xffff00,
                    }),
                    new three.MeshBasicMaterial({
                        color: 0x00ffff,
                    }),
                    new three.MeshBasicMaterial({
                        color: 0xff00ff,
                    })
                ]);
		
		var cube = new three.Mesh(geometry, material);
		cube.rotation.x = Math.PI / 4;
		cube.rotation.y = Math.PI / 4;
		scene.add(cube);
		
		rotateContainer.appendChild(renderer.domElement);
		
		var geo = new THREE.EdgesGeometry(cube.geometry); // or WireframeGeometry
		var mat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
		var wireframe = new THREE.LineSegments(geo, mat);
		cube.add(wireframe);
		camera.position.z = 5;
		
		var isDragging = false;
		var previousMousePosition = {
			x: 0,
			y: 0
		};
		$(renderer.domElement).on('mousedown', function (e) {
			isDragging = true;
		})
			.on('mousemove', function (e) {
				// console.log(e);
				var deltaMove = {
					x: e.offsetX - previousMousePosition.x,
					y: e.offsetY - previousMousePosition.y
				};
				
				if (isDragging) {
					var deltaRotationQuaternion = new three.Quaternion()
						.setFromEuler(new three.Euler(
							toRadians(deltaMove.y),
							toRadians(deltaMove.x),
							0,
							'XYZ'
						));
					cube.quaternion.multiplyQuaternions(deltaRotationQuaternion, cube.quaternion);
					console.log(radToDeg(cube.rotation.x), radToDeg(cube.rotation.y));
				}
				previousMousePosition = {
					x: e.offsetX,
					y: e.offsetY
				};
			});
			$(document).on('mouseup', function (e) {
				isDragging = false;
			});
			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function () {
				return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					function (callback) {
						window.setTimeout(callback, 1000 / 60);
					};
			})();
			var lastFrameTime = new Date().getTime() / 1000;
			var totalGameTime = 0;
			function radToDeg(rad){
				return rad*180/Math.PI
			}
			
			function update(dt, t) {
				setTimeout(function () {
					var currTime = new Date().getTime() / 1000;
					var dt = currTime - (lastFrameTime || currTime);
					totalGameTime += dt;
					update(dt, totalGameTime);
					lastFrameTime = currTime;
				}, 0);
			}
			function render() {
				renderer.render(scene, camera);
				requestAnimFrame(render);
			}
			render();
			update(0, totalGameTime);
			function toRadians(angle) {
				return angle * (Math.PI / 180);
			}
			function toDegrees(angle) {
				return angle * (180 / Math.PI);
			}
		/*Function for Timer*/
		function timer(sec){
			var timeout;		
			var timer = setInterval(function(){
				if(sec>0){
					document.getElementById("timer").innerHTML = sec/1000;
				}
				sec++;
			});
		}
	</script>
</html>