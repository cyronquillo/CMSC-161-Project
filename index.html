<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>RotoCopy 3D</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- CDN Link to Three.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
        <script src='./ParametricGeometry.js'></script>
        <!--reference your JS file here. Mine looks like below-->
        <script>
            
            // helper for the creation of sine
            function CustomSinCurve( scale ) {

                THREE.Curve.call( this );

                this.scale = ( scale === undefined ) ? 1 : scale;

            }

            CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
            CustomSinCurve.prototype.constructor = CustomSinCurve;

            CustomSinCurve.prototype.getPoint = function ( t ) {

                var tx = t * 3 - 1.5;
                var ty = Math.sin( 2 * Math.PI * t );
                var tz = 0;

                return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

            };
            
            // drawing of sine geometry
            function draw_sine(is_silhouette = false)
            {
                var path = new CustomSinCurve( 7 );
                var geometry = new THREE.TubeGeometry( path, 20, 2, 20, false );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );
                
                material.side = THREE.DoubleSide;
                var mesh = new THREE.Mesh( geometry, material );
                
                // set the rotation of the silhouette
                if (is_silhouette)
                {
                    mesh.position.set(1, 1, -5);
                    mesh.rotation.x = 3;
                    mesh.rotation.y = 5;
                }
                else
                {
                    mesh.position.set(1,1,-5);
                    mesh.rotation.y = 35;
                }
                
                scene.add( mesh );
            }

            function draw_torus_knot(is_silhouette = false)
            {
                var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 35 );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                material.side = THREE.DoubleSide;
                var torusKnot = new THREE.Mesh( geometry, material );
                torusKnot.position.set(0,0,-25);

                if (is_silhouette)
                {
                    torusKnot.rotation.z = 0.0;
                    torusKnot.rotation.x = 2.5;
                    torusKnot.rotation.y = 2.0;
                }
                
                scene.add( torusKnot );
            }

            // helper for the parameteric geometries
            function klein (u = 2, v = 5) 
            {
                u *= Math.PI;
                v *= 2 * Math.PI;
                u = u * 2;
                var x, y, z;
                if (u < Math.PI) {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
                    z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                } else {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
                    z = -8 * Math.sin(u);
                }
                y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
                return new THREE.Vector3(x, y, z);
            };

            function half_ring (is_silhouette = false)
            {
                var geometry = new THREE.RingGeometry( 18.7, 10, 8, 16, 4, 3.2 );
                if (!is_silhouette) var material = new THREE.MeshBasicMaterial( { color: 0x11bbee, side: THREE.DoubleSide } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );

                var mesh = new THREE.Mesh( geometry, material );
                mesh.rotation.x = 1.5;
                mesh.rotation.x = 3.5;
                mesh.rotation.y = 1.0;
                if (!is_silhouette)
                {
                    mesh.rotation.z = 0.0;
                    mesh.rotation.x = 2.5;
                    mesh.rotation.y = 1.0;
                }
                mesh.position.set(0,0,-25);
                scene.add( mesh );
            }
            
            function draw_heart (is_silhouette = false)
            {
                var x = 0, y = 0;

                var heartShape = new THREE.Shape();

                heartShape.moveTo( x + 5, y + 5 );
                heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
                heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );
                heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
                heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
                heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
                heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );

                var geometry = new THREE.ShapeBufferGeometry( heartShape );
                if (!is_silhouette) var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                
                var mesh = new THREE.Mesh( geometry, material ) ;
                mesh.rotation.z = 3.1;
                if (is_silhouette)
                {
                    mesh.rotation.z = 0.0;
                    mesh.rotation.x = 3.5;
                    mesh.rotation.y = 4.5;
                }
                mesh.position.set(10,10,-30);                
                scene.add( mesh );
            }

            function draw_klein (is_silhouette = false)
            {
                var geometry = new THREE.ParametricGeometry(THREE.ParametricGeometries.klein, 25, 25 );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                material.side = THREE.DoubleSide;
                var klein = new THREE.Mesh( geometry, material );
                klein.position.set(3,0, -5);
                klein.rotation.x = 5.0;
                klein.rotation.y = 13.0;
                klein.rotation.z = 0.0;
                scene.add( klein );
            }

            
            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
            const renderer = new THREE.WebGLRenderer({ antialias: true})
            
            renderer.setClearColor(new THREE.Color(0xeeeeee));
            
            camera.position.set(3, 0, 20);

            var spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-0, 30, 60)
            spotLight.intensity = 0.6
            scene.add(spotLight)


            camera.position.z = 12;

            draw_klein();

            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )

            function animate() {
            requestAnimationFrame( animate )
                renderer.render( scene, camera )
            }
            animate()
        </script>
	</body>
</html>