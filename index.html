<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>RotoCopy 3D</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- CDN Link to Three.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.js"></script>
        <!--reference your JS file here. Mine looks like below-->
        <script>

            // var THREE = require('three');
            // helper for the creation of sine
            function CustomSinCurve( scale ) {

                THREE.Curve.call( this );

                this.scale = ( scale === undefined ) ? 1 : scale;

            }

            CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
            CustomSinCurve.prototype.constructor = CustomSinCurve;

            CustomSinCurve.prototype.getPoint = function ( t ) {

                var tx = t * 3 - 1.5;
                var ty = Math.sin( 2 * Math.PI * t );
                var tz = 0;

                return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

            };
            
            function draw_torus_knot(is_silhouette = false)
            {
                var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 35 );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                material.side = THREE.DoubleSide;
                var torusKnot = new THREE.Mesh( geometry, material );
                torusKnot.position.set(0,0,-25);

                if (is_silhouette)
                {
                    torusKnot.rotation.z = 0.0;
                    torusKnot.rotation.x = 2.5;
                    torusKnot.rotation.y = 2.0;
                }
                
                scene.add( torusKnot );
            }

            function half_ring (is_silhouette = false)
            {
                var geometry = new THREE.RingGeometry( 18.7, 10, 8, 16, 4, 3.2 );
                if (!is_silhouette) var material = new THREE.MeshBasicMaterial( { color: 0x11bbee, side: THREE.DoubleSide } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );

                var mesh = new THREE.Mesh( geometry, material );
                mesh.rotation.x = 1.5;
                mesh.rotation.x = 3.5;
                mesh.rotation.y = 1.0;
                if (!is_silhouette)
                {
                    mesh.rotation.z = 0.0;
                    mesh.rotation.x = 2.5;
                    mesh.rotation.y = 1.0;
                }
                mesh.position.set(0,0,-25);
                scene.add( mesh );
            }
            

            function rand_1 (is_silhouette = false)
            {
                const v1 = 2;
                const v2 = 1;
                const v3 = 0.5;

                var group = new THREE.Group();

                // Cube
                var geometry = new THREE.BoxGeometry( 1, 1, 1 );
                for ( var i = 0; i < geometry.faces.length; i += 2 ) {
                        var hex = Math.random() * 0xffffff;
                        geometry.faces[ i ].color.setHex( hex );
                        geometry.faces[ i + 1 ].color.setHex( hex );
                }
                var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );

                if (is_silhouette) var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = 0;
                cube.position.y = 0;
                cube.position.z = 0;
                group.add( cube );

                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = 0;
                cube.position.y = 1;
                cube.position.z = 0;
                group.add( cube );

                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = 0.1;
                cube.position.y = 0.1;
                cube.position.z = 0;
                group.add( cube );
                
                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = 0.5;
                cube.position.y = 1.5;
                cube.position.z = 0.0;
                group.add( cube );

                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = -1;
                cube.position.y = 1;
                cube.position.z = 0;
                group.add( cube );

                var cube = new THREE.Mesh( geometry, material );
                cube.position.x = -1.5;
                cube.position.y = 1.5;
                cube.position.z = 0;
                group.add( cube );

                var mesh = new THREE.Mesh( group, material );

                if (is_silhouette)
                {
                    group.rotation.x = 0.5;
                    group.rotation.y = 1.5;
                }
                scene.add(group);

                group.position.set(3, 0, 5)
            }

            function rand_2 (is_silhouette = false)
            {
                const v1 = 2;
                const v2 = 1;
                const v3 = 0.5;

                var group = new THREE.Group();

                var geometry = new THREE.SphereGeometry( 5, 32, 32 );
                var material = new THREE.MeshPhongMaterial( {color: 0xffff00} );
                if (is_silhouette) var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );
                
                var sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = 2.5;
                sphere.position.y = -3.5;
                sphere.position.z = 0;
                group.add( sphere );

                var sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = 0.5;
                sphere.position.y = -3.5;
                sphere.position.z = 0;
                group.add( sphere );
                
                var sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = 2.5;
                sphere.position.y = 1.5;
                sphere.position.z = 0.0;
                group.add( sphere );


                var sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = -2.5;
                sphere.position.y = 1.5;
                sphere.position.z = 0;
                group.add( sphere );

                var mesh = new THREE.Mesh( group, material );

                if (is_silhouette)
                {
                    group.rotation.x = 0.5;
                    group.rotation.y = 1.5;
                }
                scene.add(group);

                group.position.set(3, 0, -15)
            }

            
            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
            const renderer = new THREE.WebGLRenderer({ antialias: true})
            
            renderer.setClearColor(new THREE.Color(0xeeeeee));
            
            camera.position.set(3, 0, 20);

            var spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-0, 30, 60)
            spotLight.intensity = 0.6
            scene.add(spotLight)


            camera.position.z = 12;
            
            rand_2(true);

            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )

            function animate() {
            requestAnimationFrame( animate )
                renderer.render( scene, camera )
            }
            animate()
        </script>
	</body>
</html>