<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>RotoCopy 3D</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- CDN Link to Three.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>        
        <!--reference your JS file here. Mine looks like below-->
        <script>
            var three = THREE;
            // helper for the creation of sine
            function CustomSinCurve( scale ) {

                THREE.Curve.call( this );

                this.scale = ( scale === undefined ) ? 1 : scale;

            }

            CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
            CustomSinCurve.prototype.constructor = CustomSinCurve;

            CustomSinCurve.prototype.getPoint = function ( t ) {

                var tx = t * 3 - 1.5;
                var ty = Math.sin( 2 * Math.PI * t );
                var tz = 0;

                return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

            };
            
            // drawing of sine geometry
            function draw_sine(is_silhouette = false)
            {
                var path = new CustomSinCurve( 7 );
                var geometry = new THREE.TubeGeometry( path, 20, 2, 20, false );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );
                
                // material.side = THREE.DoubleSide;
                var mesh = new THREE.Mesh( geometry, material );
                
                // set the rotation of the silhouette
                if (is_silhouette)
                {
                    mesh.position.set(1, 1, -5);
                    mesh.rotation.x = 3;
                    mesh.rotation.y = 5;
                }
                else
                {
                    mesh.position.set(1,1,-5);
                    mesh.rotation.y = 35;
                }
                
                scene.add( mesh );
            }

            function draw_torus_knot(is_silhouette)
            {
                var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 35 );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                material.side = THREE.DoubleSide;
                var torusKnot = new THREE.Mesh( geometry, material );
                torusKnot.position.set(0,0,-25);

                if (true)
                {
                    torusKnot.rotation.z = 0;
                    torusKnot.rotation.x = 2.5;
                    torusKnot.rotation.y = 2.0;
                }
                var magnitude = Math.pow(Math.pow(torusKnot.rotation.y,2) + Math.pow(torusKnot.rotation.x,2), 0.5)
                console.log(magnitude)
                normie = {
                    x: torusKnot.rotation.x/magnitude,
                    y: torusKnot.rotation.y/magnitude
                }
                // console.log(normie)

                scene.add( torusKnot );
                return torusKnot;
            }

            // helper for the parameteric geometries
            function klein (u = 2, v = 5) 
            {
                u *= Math.PI;
                v *= 2 * Math.PI;
                u = u * 2;
                var x, y, z;
                if (u < Math.PI) {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
                    z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                } else {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
                    z = -8 * Math.sin(u);
                }
                y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
                return new THREE.Vector3(x, y, z);
            };

            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
            const renderer = new THREE.WebGLRenderer({ antialias: true})

            renderer.setClearColor(new THREE.Color(0xeeeeee));
            
            camera.position.set(3, 0, 20);

            var spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-0, 30, 60)
            spotLight.intensity = 0.6
            scene.add(spotLight)


            camera.position.z = 12;


            var geometry = new THREE.ParametricGeometry( klein, 25, 25 );
            var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
            material.side = THREE.DoubleSide;
            var klein = new THREE.Mesh( geometry, material );
            klein.position.set(3,0, -5);
            klein.rotation.x = 5.0;
            klein.rotation.y = 13.0;
            klein.rotation.z = 4.5;
            // scene.add( klein );
            
            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )
            
            overlay = draw_torus_knot(true)
            currentObject = draw_torus_knot(false)
            
            /* rotating object */
            var isDragging = false;
                var previousMousePosition = {
                    x: 0,
                    y: 0
                };

                $(renderer.domElement).on('mousedown', function (e) {
                    isDragging = true;
                })
                    .on('mousemove', function (e) {
                        // console.log(e);
                        var deltaMove = {
                            x: e.offsetX - previousMousePosition.x,
                            y: e.offsetY - previousMousePosition.y
                        };

                        if (isDragging) {

                            var deltaRotationQuaternion = new three.Quaternion()
                                .setFromEuler(new three.Euler(
                                    toRadians(deltaMove.y),
                                    toRadians(deltaMove.x),
                                    0,
                                    'XYZ'
                                )).normalize();
                            currentObject.quaternion.multiplyQuaternions(deltaRotationQuaternion, currentObject.quaternion);
                            var mag = (Math.pow(Math.pow(currentObject.rotation.y, 2) + Math.pow(currentObject.rotation.x, 2), 0.5))
                            var normie = {
                                x: currentObject.rotation.x/mag,
                                y: currentObject.rotation.y/mag
                            }
                            console.log(mag)

                        }
                        previousMousePosition = {
                            x: e.offsetX,
                            y: e.offsetY
                        };
                    });
                /* */

                $(document).on('mouseup', function (e) {
                    isDragging = false;
                });



                // shim layer with setTimeout fallback
                window.requestAnimFrame = (function () {
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        function (callback) {
                            window.setTimeout(callback, 1000 / 60);
                        };
                })();

                var lastFrameTime = new Date().getTime() / 1000;
                var totalGameTime = 0;
                function radToDeg(rad) {
                    return rad * 180 / Math.PI
                }

                function update(dt, t) {
                    //console.log(dt, t);

                    //camera.position.z += 1 * dt;
                    //currentObject.rotation.x += 1 * dt;
                    //currentObject.rotation.y += 1 * dt;

                    setTimeout(function () {
                        var currTime = new Date().getTime() / 1000;
                        var dt = currTime - (lastFrameTime || currTime);
                        totalGameTime += dt;

                        update(dt, totalGameTime);

                        lastFrameTime = currTime;
                    }, 0);
                }

            /* rotating object end */
            function animate() {
            requestAnimationFrame( animate )
                renderer.render( scene, camera )
                // requestAnimFrame(animate);
            }

            animate()
            update(0, totalGameTime);

            function toRadians(angle) {
                    return angle * (Math.PI / 180);
                }

            function toDegrees(angle) {
                return angle * (180 / Math.PI);
            }
        </script>
	</body>
</html>