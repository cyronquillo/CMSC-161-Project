<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>RotoCopy 3D</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <!-- CDN Link to Three.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
        <!--reference your JS file here. Mine looks like below-->
        <script>

            // helper for the creation of sine
            function CustomSinCurve( scale ) {

                THREE.Curve.call( this );

                this.scale = ( scale === undefined ) ? 1 : scale;

            }

            CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
            CustomSinCurve.prototype.constructor = CustomSinCurve;

            CustomSinCurve.prototype.getPoint = function ( t ) {

                var tx = t * 3 - 1.5;
                var ty = Math.sin( 2 * Math.PI * t );
                var tz = 0;

                return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

            };

            // drawing of sine geometry
            function draw_sine(is_silhouette = false)
            {
                var path = new CustomSinCurve( 7 );
                var geometry = new THREE.TubeGeometry( path, 20, 2, 20, false );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

                material.side = THREE.DoubleSide;
                var mesh = new THREE.Mesh( geometry, material );

                // set the rotation of the silhouette
                if (is_silhouette)
                {
                    mesh.position.set(1, 1, -5);
                    mesh.rotation.x = 3;
                    mesh.rotation.y = 5;
                }
                else
                {
                    mesh.position.set(1,1,-5);
                    mesh.rotation.y = 35;
                }

                scene.add( mesh );
            }

            function draw_torus_knot(is_silhouette = false)
            {
                var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 35 );
                if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
                else var material = new THREE.MeshBasicMaterial( { color: 0x000000  } );
                material.side = THREE.DoubleSide;
                var torusKnot = new THREE.Mesh( geometry, material );
                torusKnot.position.set(0,0,-25);

                if (is_silhouette)
                {
                    torusKnot.rotation.z = 0.4;
                    torusKnot.rotation.x = 2.5;
                    torusKnot.rotation.y = 2.0;
                }

                scene.add( torusKnot );
            }

			function draw_cube_cluster (is_silhouette = false)
			{
				const v1 = 2;
				const v2 = 1;
				const v3 = 0.5;


				if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
				else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

				material.side = THREE.DoubleSide;
				var group = new THREE.Group();

				// Cube
				var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				for ( var i = 0; i < geometry.faces.length; i += 2 ) {
						var hex = Math.random() * 0xffffff;
						geometry.faces[ i ].color.setHex( hex );
						geometry.faces[ i + 1 ].color.setHex( hex );
				}
				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.15320661216709408 * v1 - v2;
				cube.position.y = 0.07876428314069295 * v1 - v2;
				cube.position.z = 0.8142309474976139 * v1 - v2;
				cube.scale.multiplyScalar( 0.6073612142471205 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.8238856026329542 * v1 - v2;
				cube.position.y = 0.66234543201572 * v1 - v2;
				cube.position.z = 0.19729624573916293 * v1 - v2;
				cube.scale.multiplyScalar( 0.943280559550606 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.9926546696804588 * v1 - v2;
				cube.position.y = 0.8765778360719039 * v1 - v2;
				cube.position.z = 0.3813242309186571 * v1 - v2;
				cube.scale.multiplyScalar( 0.7053419691199112 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.6031081092923989 * v1 - v2;
				cube.position.y = 0.8956021196243023 * v1 - v2;
				cube.position.z = 0.4731741849321296 * v1 - v2;
				cube.scale.multiplyScalar( 0.23116386542098222 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.6045386623736511 * v1 - v2;
				cube.position.y = 0.1515978218003433 * v1 - v2;
				cube.position.z = 0.8493106134514443 * v1 - v2;
				cube.scale.multiplyScalar( 0.40668949065033777 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.5256624623464787 * v1 - v2;
				cube.position.y = 0.9443117513492909 * v1 - v2;
				cube.position.z = 0.7097300006134728 * v1 - v2;
				cube.scale.multiplyScalar( 0.3425465034979849 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.1499476982591419 * v1 - v2;
				cube.position.y = 0.6475285864064242 * v1 - v2;
				cube.position.z = 0.9503485391441944 * v1 - v2;
				cube.scale.multiplyScalar( 0.10376880382116371 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.7703502139752667 * v1 - v2;
				cube.position.y = 0.5734314508105554 * v1 - v2;
				cube.position.z = 0.4395017168141062 * v1 - v2;
				cube.scale.multiplyScalar( 0.7686332584105269 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.5502084500031799 * v1 - v2;
				cube.position.y = 0.9254106876840575 * v1 - v2;
				cube.position.z = 0.9319475056412949 * v1 - v2;
				cube.scale.multiplyScalar( 0.6358699022891223 + v3 );
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0.6798803741571171 * v1 - v2;
				cube.position.y = 0.38257666783122146 * v1 - v2;
				cube.position.z = 0.830885184120336 * v1 - v2;
				cube.scale.multiplyScalar( 0.055655523163026466 + v3 );
				group.add( cube );

				var mesh = new THREE.Mesh( group, material );
				scene.add(group);
			}

			function draw_cross (is_silhouette = false)
			{
				const v1 = 2;
				const v2 = 1;
				const v3 = 0.5;

				if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
				else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

				material.side = THREE.DoubleSide;
				var group = new THREE.Group();

				// Cube
				var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				for ( var i = 0; i < geometry.faces.length; i += 2 ) {
						var hex = Math.random() * 0xffffff;
						geometry.faces[ i ].color.setHex( hex );
						geometry.faces[ i + 1 ].color.setHex( hex );
				}
				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );


				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = -1;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 1;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 2;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 3;
				cube.position.z = 0;
				group.add( cube );

				var mesh = new THREE.Mesh( group, material );
				scene.add(group);
			}


			function draw_stairs (is_silhouette = false)
			{
				const v1 = 2;
				const v2 = 1;
				const v3 = 0.5;

				if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
				else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

				material.side = THREE.DoubleSide;
				var group = new THREE.Group();

				// Cube
				var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				for ( var i = 0; i < geometry.faces.length; i += 2 ) {
						var hex = Math.random() * 0xffffff;
						geometry.faces[ i ].color.setHex( hex );
						geometry.faces[ i + 1 ].color.setHex( hex );
				}
				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 1;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 2;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 3;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 4;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );


				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 2;
				cube.position.y = 0;
				cube.position.z = -4;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 2;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 3;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );


				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 2;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 1;
				cube.position.y = 2;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 2;
				cube.position.y = 2;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 3;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 1;
				cube.position.y = 3;
				cube.position.z = 0;
				group.add( cube );

				cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 4;
				cube.position.z = 0;
				group.add( cube );

				var mesh = new THREE.Mesh( group, material );

				group.rotation.z = 0.4;
				group.rotation.x = 2.5;
				group.rotation.y = 2.0;

				scene.add(group);
			}


			function draw_tetris_z1 (is_silhouette = false)
			{
				const v1 = 2;
				const v2 = 1;
				const v3 = 0.5;

				if (!is_silhouette) var material = new THREE.MeshPhongMaterial( { color: 0x4283f4 } );
				else var material = new THREE.MeshBasicMaterial( { color: 0x000000 } );

				material.side = THREE.DoubleSide;
				var group = new THREE.Group();

				// Cube
				var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				for ( var i = 0; i < geometry.faces.length; i += 2 ) {
						var hex = Math.random() * 0xffffff;
						geometry.faces[ i ].color.setHex( hex );
						geometry.faces[ i + 1 ].color.setHex( hex );
				}
				var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );


				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 0;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 1;
				cube.position.y = 1;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = -1;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = -2;
				cube.position.y = 0;
				cube.position.z = 0;
				group.add( cube );

				var mesh = new THREE.Mesh( group, material );
				scene.add(group);
			}

            // helper for the parameteric geometries
            function klein (u = 2, v = 5)
            {
                u *= Math.PI;
                v *= 2 * Math.PI;
                u = u * 2;
                var x, y, z;
                if (u < Math.PI) {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
                    z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
                } else {
                    x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
                    z = -8 * Math.sin(u);
                }
                y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
                return new THREE.Vector3(x, y, z);
            };

            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
            const renderer = new THREE.WebGLRenderer({ antialias: true})

            renderer.setClearColor(new THREE.Color(0xeeeeee));

            camera.position.set(3, 0, 20);

            var spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-0, 30, 60)
            spotLight.intensity = 0.6
            scene.add(spotLight)


            camera.position.z = 12;


            // var geometry = new THREE.ParametricGeometry( klein, 25, 25 );
            // var material = new THREE.MeshPhongMaterial( { color: 0x11bbee } );
            // material.side = THREE.DoubleSide;
            // var klein = new THREE.Mesh( geometry, material );
            // klein.position.set(3,0, -5);
            // klein.rotation.x = 5.0;
            // klein.rotation.y = 13.0;
            // klein.rotation.z = 4.5;
            // scene.add( klein );

			draw_stairs(false);

            renderer.setSize( window.innerWidth, window.innerHeight )
            document.body.appendChild( renderer.domElement )

            function animate() {
            requestAnimationFrame( animate )
                renderer.render( scene, camera )
            }
            animate()
        </script>
	</body>
</html>
